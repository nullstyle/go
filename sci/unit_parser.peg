package sci

type UnitParser Peg {
  System *System
  Result Unit
  Err error
  stack []Unit
}

first <- sp  e1 !. { 
  if len(p.stack) != 1 {
    p.Err = &ParseError{Input: p.Buffer, FailurePhase: "stack drain"}
    return
  }

  p.Result = p.stack[0]
}

e1 <- inverted_units / units

units <- unit+
inverted_units <- '/' sp unit+ {
  d, err := p.popUnit()
  if err != nil {
    p.Err = err
    return
  }

  p.pushUnit(&DivUnit{N: Nil, D: d})
}

unit <- parens_exp / parens / name_exp / name / div / mul

parens_exp <- open unit+ close '^' < exp > {
  err := p.pushExpParens(buffer[begin:end])
  if err != nil {
    p.Err = err
    return
  }
}
parens <- open unit+ close

div <- '/' sp unit {
  d, err := p.popUnit()
  if err != nil {
    p.Err = err
    return
  }

  n, err := p.popUnit()
  if err != nil {
    p.Err = err
    return
  }

  p.pushUnit(&DivUnit{N:n, D:d})
}

mul <- '*' sp unit {
  last, err := p.popUnit()
  if err != nil {
    p.Err = err
    return
  }

  first, err := p.popUnit()
  if err != nil {
    p.Err = err
    return
  }

  p.pushUnit(&MulUnit{first,last})
}

name_exp <- < [[A-Z]]+ '^' exp > sp { 
  err := p.pushExpUnit(buffer[begin:end])
  if err != nil {
    p.Err = err
    return
  }
}

name <- < [[A-Z]]+ > sp { 
  p.log("in name:", buffer[begin:end])
  defer p.log("out name_exp")
  found, err := p.System.LookupUnit(buffer[begin:end])
  if err != nil {
    p.Err = err
    return
  }

  p.pushUnit(found)
}

exp <- minus? [1-9][0-9]*

minus <- '-'
open <- '(' sp
close <- ')' sp
sp <- ( ' ' / '\t' )*